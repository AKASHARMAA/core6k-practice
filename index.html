<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Japanese Practice v12 (Kuromoji Standard)</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap"
        rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            /* Light Mode (Default) */
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --success: #10b981;
            --error: #ef4444;
            --text: #1f2937;
            --subtext: #6b7280;
            --bg: #f3f4f6;
            --card-bg: #ffffff;
            --border: #e5e7eb;
            --input-bg: #ffffff;
            --mic-bg: linear-gradient(135deg, var(--primary), var(--primary-dark));
            --mic-shadow: rgba(99, 102, 241, 0.4);
        }

        body.dark-mode {
            /* Dark Mode (Slate Palette) */
            --primary: #818cf8;
            /* Softer Indigo */
            --primary-dark: #6366f1;
            --success: #34d399;
            /* Softer Green */
            --error: #f87171;
            /* Softer Red */
            --text: #f1f5f9;
            /* Slate 100 */
            --subtext: #94a3b8;
            /* Slate 400 */
            --bg: #0f172a;
            /* Slate 900 */
            --card-bg: #1e293b;
            /* Slate 800 */
            --border: #334155;
            /* Slate 700 */
            --input-bg: #334155;
            /* Slate 700 */
            --mic-bg: linear-gradient(135deg, #6366f1, #4f46e5);
            /* Keep mic pop */
            --mic-shadow: rgba(99, 102, 241, 0.2);
        }

        body {
            font-family: 'Roboto', 'Noto Sans JP', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        #main-container {
            width: 100%;
            max-width: 650px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #upload-card {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .btn-upload {
            border: 2px dashed var(--border);
            color: var(--subtext);
            background-color: var(--card-bg);
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-upload:hover {
            border-color: var(--primary);
            color: var(--primary);
            background-color: var(--bg);
        }

        input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .filter-group {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-family: inherit;
            color: var(--text);
            background-color: var(--input-bg);
            outline: none;
            cursor: pointer;
        }

        select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px #e0e7ff;
            outline: none;
        }

        /* Continuous Mode Toggle */
        .toggle-container {
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border);
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary);
        }

        input:checked+.slider:before {
            transform: translateX(24px);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        #card {
            background: var(--card-bg);
            width: 100%;
            padding: 0;
            border-radius: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
            position: relative;
            display: none;
        }

        #progress-container {
            width: 100%;
            height: 6px;
            height: 6px;
            background-color: var(--border);
        }

        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            width: 0%;
            transition: width 0.3s ease;
        }

        .content {
            padding: 40px 40px 30px 40px;
            text-align: center;
        }

        h1 {
            font-size: 32px;
            margin: 8px 0;
            color: var(--text);
            font-weight: 700;
        }

        h2 {
            font-size: 20px;
            color: var(--primary);
            margin-bottom: 4px;
            font-weight: 700;
        }

        .label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--subtext);
            margin-bottom: 4px;
            display: block;
            font-weight: 600;
        }

        .kana {
            font-size: 22px;
            color: var(--subtext);
            margin-bottom: 20px;
            display: block;
        }

        .meaning {
            font-size: 16px;
            color: var(--subtext);
            font-style: italic;
            margin-top: 4px;
        }

        #status {
            margin-top: 20px;
            font-weight: 600;
            color: var(--subtext);
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #debug {
            margin-top: 8px;
            font-size: 13px;
            color: #9ca3af;
            min-height: 20px;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
            padding-bottom: 40px;
        }

        .btn-nav {
            background: var(--card-bg);
            border: 2px solid var(--border);
            color: var(--subtext);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-nav:hover {
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-2px);
        }

        .btn-nav:active {
            transform: translateY(0);
        }

        #btn-mic {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 15px var(--mic-shadow);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #btn-mic:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6);
        }

        #btn-mic:active {
            transform: scale(0.95);
        }

        #btn-mic.listening {
            background: #ffa726;
            animation: pulse 1.5s infinite;
        }

        #btn-mic.speaking {
            background: #3b82f6;
            animation: pulse-blue 1.5s infinite;
        }

        @keyframes pulse-blue {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        hr {
            border: 0;
            height: 1px;
            background: var(--border);
            margin: 25px 0;
        }

        .keyboard-hint {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 11px;
            color: #d1d5db;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 167, 38, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 167, 38, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 167, 38, 0);
            }
        }

        .active-mode {
            color: var(--success);
            font-weight: 700;
        }

        /* Dark Mode Toggle Button */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            color: var(--subtext);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .theme-toggle:hover {
            color: var(--text);
            border-color: var(--text);
        }
    </style>
</head>

<body>
    <button class="theme-toggle" onclick="toggleTheme()">
        <i class="fas fa-moon"></i> <span>Dark Mode</span>
    </button>

    <div id="main-container">
        <div id="upload-card">
            <div class="file-input-wrapper">
                <button class="btn-upload"><i class="fas fa-upload"></i> Upload csv File</button>
                <input type="file" id="csv-file" accept=".csv,.txt,.tsv" />
            </div>
            <div class="filter-group">
                <label for="pos-filter" style="font-size: 14px; font-weight: 500; color: #64748b;">Filter by
                    POS:</label>
                <select id="pos-filter" disabled>
                    <option value="all">All</option>
                </select>
            </div>

            <div class="toggle-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="continuous-toggle">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label" id="toggle-label-text">Continuous Mode</span>
            </div>

            <div id="file-info" style="margin-top: 10px; font-size: 12px; color: #94a3b8;"></div>
        </div>

        <div id="card">
            <div id="progress-container">
                <div id="progress-bar"></div>
            </div>
            <div class="content">
                <span class="label">Target Word</span>
                <h1 id="target-word">...</h1>
                <p class="meaning" id="word-meaning">...</p>
                <hr>
                <span class="label">Sentence</span>
                <h2 id="target-text" style="font-size: 26px; color: var(--text);">...</h2>
                <span id="target-kana" class="kana">...</span>
                <p class="meaning" id="sentence-meaning" style="color: #6b7280;">... </p>
                <div id="status"><i class="fas fa-arrow-up"></i> Press Space</div>
                <div id="debug"></div>
            </div>
            <div class="controls">
                <button class="btn-nav" onclick="prevCard()" title="Previous (Left Arrow)"><i
                        class="fas fa-arrow-left"></i></button>
                <button id="btn-mic" onclick="togglePlayListen()" title="Start/Stop (Space)"><i
                        class="fas fa-microphone"></i></button>
                <button class="btn-nav" onclick="nextCard()" title="Next (Right Arrow)"><i
                        class="fas fa-arrow-right"></i></button>
            </div>
            <div class="keyboard-hint">Use Arrow Keys & Space</div>
        </div>
    </div>

    <script>
        let allSentences = [];
        let filteredSentences = [];
        let currentIndex = 0;
        const POS_COLUMN_INDEX = 8;

        // Continuous Mode
        let isContinuous = false;
        document.getElementById('continuous-toggle').addEventListener('change', (e) => {
            isContinuous = e.target.checked;
            const label = document.getElementById('toggle-label-text');
            if (isContinuous) {
                label.classList.add('active-mode');
                label.innerText = "Continuous Mode: ON";
            } else {
                label.classList.remove('active-mode');
                label.innerText = "Continuous Mode";
            }
        });

        document.getElementById('csv-file').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('file-info').innerText = "Loading: " + file.name;
            const reader = new FileReader();
            reader.onload = function (e) {
                parseCSV(e.target.result);
            };
            reader.readAsText(file);
        });

        function parseCSV(content) {
            const lines = content.split('\n');
            allSentences = [];
            const posSet = new Set();

            lines.forEach(line => {
                if (!line.trim()) return;
                const cols = line.split('\t');
                if (cols.length < 6) return;

                const word = cols[0] ? cols[0].trim() : "";
                const word_meaning = cols[3] ? cols[3].trim() : "";
                const text = cols[4] ? cols[4].trim() : "";
                const kana_raw = cols[5] ? cols[5].trim() : "";
                const sentence_meaning = cols[6] ? cols[6].trim() : "";
                const pos = (cols.length > POS_COLUMN_INDEX && cols[POS_COLUMN_INDEX]) ? cols[POS_COLUMN_INDEX].trim() : "Unknown";
                const kana = kana_raw.replace(/ /g, "").replace(/　/g, "");

                allSentences.push({ word, word_meaning, text, kana, sentence_meaning, pos });
                if (pos) posSet.add(pos);
            });

            document.getElementById('file-info').innerText = `Loaded ${allSentences.length} sentences.`;
            populatePOSFilter(Array.from(posSet).sort());
            // Restore last used POS filter if possible, else Default to "all"
            const lastPos = localStorage.getItem('japanese_practice_last_pos') || "all";
            document.getElementById('pos-filter').value = lastPos;
            filterSentences(lastPos);
            document.getElementById('card').style.display = 'block';
        }

        // --- BOOKMARKING SYSTEM ---
        function saveProgress(pos, index) {
            localStorage.setItem(`japanese_practice_progress_${pos}`, index);
        }

        function loadProgress(pos) {
            return parseInt(localStorage.getItem(`japanese_practice_progress_${pos}`)) || 0;
        }

        function populatePOSFilter(posList) {
            const select = document.getElementById('pos-filter');
            select.innerHTML = '<option value="all">All Parts of Speech</option>';
            posList.forEach(pos => {
                const option = document.createElement('option');
                option.value = pos;
                option.innerText = pos;
                select.appendChild(option);
            });
            select.disabled = false;
        }

        document.getElementById('pos-filter').addEventListener('change', (e) => {
            filterSentences(e.target.value);
        });

        function filterSentences(pos) {
            // Save current POS choice
            localStorage.setItem('japanese_practice_last_pos', pos);

            if (pos === "all") filteredSentences = [...allSentences];
            else filteredSentences = allSentences.filter(s => s.pos === pos);

            // Restore progress for this POS
            currentIndex = loadProgress(pos);
            // Safety check
            if (currentIndex >= filteredSentences.length) currentIndex = 0;

            updateDisplay();
            document.getElementById('pos-filter').blur();
        }

    </script>

    <!-- Kuromoji Library (Standard) -->
    <script src="https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/build/kuromoji.js"></script>

    <script>
        // ... (previous variables) ...

        // --- KUROMOJI TOKENIZER ---
        let tokenizer = null;
        let isDictLoaded = false;

        function initKuromoji() {
            const fileInfo = document.getElementById('file-info');
            const startBtn = document.getElementById('btn-mic');

            fileInfo.innerHTML = "<b>Loading AI Engine (~1.6MB)... Please Wait.</b>";
            fileInfo.style.color = "blue";
            startBtn.disabled = true;
            startBtn.innerText = "Downloading...";

            // --- NUCLEAR OPTION V2: XHR INTERCEPTOR ☢️ ---
            // If the browser/library tries to fetch "https://akasharmaa.github.io/raw.githubusercontent.com/...",
            // or "https://akasharmaa.github.io/https://raw.githubusercontent.com/..."
            // we catch ANYTHING with "raw.githubusercontent.com" and FORCE it to be absolute.
            (function () {
                const originalOpen = XMLHttpRequest.prototype.open;
                XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
                    if (typeof url === 'string') {
                        if (url.includes('raw.githubusercontent.com')) {
                            // Force absolute URL: "https://raw.githubusercontent.com/..."
                            // This fixes cases where origin is prepended AND protocol is missing.
                            const cleanPath = url.split('raw.githubusercontent.com')[1];
                            const fixed = "https://raw.githubusercontent.com" + cleanPath;

                            console.warn("☢️ Nuclear Interceptor V2 Fixed URL:", url, "->", fixed);
                            url = fixed;
                        }
                    }
                    return originalOpen.apply(this, arguments);
                };
            })();

            // Use Standard Kuromoji + GitHub Raw (Absolute URL)
            // 1. We use the official library (no forks).
            // 2. We use GitHub Raw for the dictionary because it serves .gz files as 'octet-stream'.
            //    This prevents the browser from unzipping it automatically, allowing kuromoji.js
            //    to do the unzipping itself (which prevents the "Invalid Signature" error).

            kuromoji.builder({ dicPath: "//raw.githubusercontent.com/takuyaa/kuromoji.js/master/dict/" }).build(function (err, _tokenizer) {
                if (err) {
                    console.error("Kuromoji Load Error:", err);
                    fileInfo.innerHTML = `Error: Dictionary Load Failed. <br>Details: ${err.message}`;
                    startBtn.innerText = "Load Failed";
                    return;
                }
                tokenizer = _tokenizer;
                isDictLoaded = true;
                console.log("Kuromoji Tokenizer Ready");

                startBtn.disabled = false;
                // RESTORED UI: Mic Icon instead of text
                startBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                fileInfo.style.color = "green";

                if (allSentences.length > 0) fileInfo.innerHTML = `Loaded ${allSentences.length} sentences. <b>Engine Ready.</b>`;
                else fileInfo.innerHTML = "<b>Engine Ready.</b> Please Upload CSV.";
            });
        }

        // Helper to convert Tokenizer Output (Katakana) -> Hiragana
        function katakanaToHiragana(src) {
            return src.replace(/[\u30a1-\u30f6]/g, function (match) {
                var chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        }

        // Get Official Reading from Text using Kuromoji
        function getOfficialReading(text) {
            if (!tokenizer) return null;
            const tokens = tokenizer.tokenize(text);
            // Concatenate readings
            let reading = tokens.map(t => {
                // return t.reading (Katakana) or t.surface_form (if no reading, e.g. punctuation)
                // Note: 'reading' field might be undefined for some symbols, fallback to surface_form
                return t.reading ? t.reading : t.surface_form;
            }).join("");

            return katakanaToHiragana(reading);
        }
        // Initialize immediately
        initKuromoji();


        // --- ASR LOGIC ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.interimResults = false;
            recognition.maxAlternatives = 10;
            setupRecognitionHandlers();
        } else {
            alert("Web Speech API not supported. Please use Chrome/Edge.");
        }

        function setupRecognitionHandlers() {
            recognition.onresult = function (event) {
                try {
                    const resultsList = event.results[0];
                    const spokenRawAll = resultsList[0].transcript; // Get full raw text

                    // --- VOICE COMMAND: "NEXT" ---
                    // If user says "Next", skip to next card immediately
                    if (spokenRawAll.toLowerCase().includes("next")) {
                        console.log("Voice Command: NEXT detected.");
                        document.getElementById('status').innerText = "Skipping (Voice Command)...";
                        isManualStop = true; // Prevent auto-restart loop for a moment
                        recognition.stop();
                        setTimeout(() => {
                            nextCard();
                            if (isContinuous) speakAndListen(); // Resume listening after skip
                        }, 500);
                        return;
                    }

                    const s = filteredSentences[currentIndex];

                    // Targets
                    const targetKanaRaw = s.kana.replace(/[。、！？\s]/g, '');
                    const targetKanjiRaw = s.text.replace(/[。、！？\s]/g, ''); // Fix: Define targetKanjiRaw
                    // Normalize Target: Strict (Keep 'っ')
                    const targetKanaNorm = normalizeJapanese(targetKanaRaw);

                    let matchFound = false;
                    let heardLog = [];
                    let maxSim = 0.0;

                    for (let i = 0; i < resultsList.length; i++) {
                        let spokenRaw = resultsList[i].transcript;
                        let spokenClean = spokenRaw.replace(/[。、！？\s]/g, '');
                        spokenClean = normalizeNumbers(spokenClean);
                        spokenClean = katakanaToHiragana(spokenClean);

                        // v10: Keep 'っ' for strict mode
                        let spokenDisplay = spokenClean;

                        // v11: NO STRIPPING 'っ' (Strict Mode)
                        // spokenClean = spokenClean.replace(/っ/g, ''); 
                        heardLog.push(spokenDisplay);

                        // --- STRATEGY 1: LEGACY LOGIC (Primary) ---
                        // Compare Spoken against Target (Reference) with Levenshtein
                        // If this matches (>90%), we TRUST it immediately.

                        let simKanji = getSimilarity(spokenClean, targetKanjiRaw); // Raw Text (Strict)
                        let simKana = getSimilarity(spokenClean, targetKanaNorm); // Strict Target (Keep 'っ')

                        if (simKanji >= 0.90 || simKana >= 0.90) {
                            matchFound = true;
                            if (simKanji > maxSim) maxSim = simKanji;
                            if (simKana > maxSim) maxSim = simKana;
                        }

                        // Normalized Check (Standard)
                        let spokenNorm = normalizeJapanese(spokenRaw);
                        let targetKanjiNorm = normalizeJapanese(targetKanjiRaw);
                        let targetKanaNorm2 = normalizeJapanese(targetKanaRaw);

                        let simKanjiNorm = getSimilarity(spokenNorm, targetKanjiNorm);
                        let simKanaNorm = getSimilarity(spokenNorm, targetKanaNorm2);

                        let bestThisRound = Math.max(simKanji, simKana, simKanjiNorm, simKanaNorm);
                        if (bestThisRound > maxSim) maxSim = bestThisRound;

                        if (matchFound || simKanjiNorm >= 0.90 || simKanaNorm >= 0.90) {
                            matchFound = true;
                            break;
                        }

                        // --- STRATEGY 2: REGEX MATCHING (Fallback) ---
                        // Only run if Legacy didn't find a high match.

                        if (!matchFound) {
                            if (!isDictLoaded) {
                                // Fallback check if dict failed
                                if (spokenClean === s.text.replace(/[。、！？\s]/g, '')) matchFound = true;
                            } else {
                                // 1. Get Official Reading from Kuromoji
                                // e.g., "明日" -> "あした"
                                let kuromojiReading = getOfficialReading(spokenClean);

                                // Debug: Show user what we "calculated"
                                let debugMsg = `[Raw]: ${spokenClean} <br> [Reading]: ${kuromojiReading || "Pending..."}`;
                                document.getElementById('debug').innerHTML = debugMsg;

                                // 2. Compare Kuromoji Reading vs Target Kana
                                if (kuromojiReading) {
                                    console.log(`Kuromoji Check: Spoken '${spokenClean}' -> Reading '${kuromojiReading}' vs Target '${targetKanaNorm}'`);

                                    let simKuromoji = getSimilarity(kuromojiReading, targetKanaNorm);
                                    if (simKuromoji > maxSim) maxSim = simKuromoji;

                                    if (simKuromoji >= 0.90) {
                                        matchFound = true;
                                        console.log("Kuromoji Match Hit!");
                                        break;
                                    }
                                }
                            }
                        }

                        // Fallback: Calculate similarity using standard normalization if Regex fails
                        // (Just to show a score if no perfect match)
                        let baseSim = getSimilarity(spokenClean, targetKanaRaw);
                        if (baseSim > maxSim) maxSim = baseSim;
                        if (baseSim >= 0.9) matchFound = true;
                    }

                    isListening = false;
                    document.getElementById('btn-mic').classList.remove('listening');

                    if (matchFound) {
                        document.getElementById('status').innerHTML = '<i class="fas fa-check-circle"></i> Perfect!';
                        document.getElementById('status').style.color = "#10b981";
                        document.getElementById('debug').innerText = "Matched: " + heardLog[0] + " (100%)";

                        // AUTO-ADVANCE
                        if (isContinuous) {
                            setTimeout(() => {
                                nextCard();
                                speakAndListen();
                            }, 1500);
                        } else {
                            setTimeout(() => nextCard(), 1000);
                        }

                    } else {
                        document.getElementById('status').innerHTML = '<i class="fas fa-times-circle"></i> Try again';
                        document.getElementById('status').style.color = "#ef4444";
                        document.getElementById('debug').innerText = "Heard: " + heardLog[0] + " (Sim: " + (maxSim * 100).toFixed(0) + "%)";

                        // AUTO-RETRY
                        if (isContinuous) {
                            setTimeout(() => {
                                speakAndListen();
                            }, 2000);
                        }
                    }
                } catch (e) {
                    console.error("CRITICAL ERROR IN ONRESULT:", e);
                    document.getElementById('debug').innerText = "ERROR: " + e.message;
                    isListening = false;
                    document.getElementById('btn-mic').classList.remove('listening');
                }
            };

            recognition.onend = function () {
                isListening = false;
                document.getElementById('btn-mic').classList.remove('listening');

                // --- CONTINUOUS MODE RESTART ---
                // If Continuous Mode is ON, and we didn't manually stop it (isManualStop),
                // restart listening after 2 seconds.
                if (isContinuous && !isManualStop && !isSpeaking) {
                    console.log("Continuous Mode: Restarting in 2s...");
                    document.getElementById('status').innerText = "Restarting...";
                    setTimeout(() => {
                        // Only restart if still continuous and not listening
                        if (isContinuous && !isListening && !isSpeaking && !isManualStop) speakAndListen();
                    }, 2000);
                }
            };

            // Removed onspeechend to rely on onend for restart logic
            // recognition.onspeechend = function () { ... }

            recognition.onerror = function (event) {
                if (event.error === 'no-speech' && isContinuous) {
                    document.getElementById('status').innerText = "No speech detected. Listening again...";
                    setTimeout(() => speakAndListen(), 1000);
                    return;
                }
                document.getElementById('status').innerText = "Error: " + event.error;
                isListening = false;
                document.getElementById('btn-mic').classList.remove('listening');
            };
        }

        // --- HELPERS ---

        function normalizeJapanese(text) {
            let t = text;
            t = t.replace(/出来ます/g, "できます").replace(/出来る/g, "できる");
            t = t.replace(/下さい/g, "ください").replace(/ください/g, "ください");
            t = t.replace(/致します/g, "いたします").replace(/居ます/g, "います");
            t = t.replace(/有ります/g, "あります").replace(/成ります/g, "なります");
            t = t.replace(/私/g, "わたし").replace(/僕/g, "ぼく");
            t = t.replace(/誰/g, "だれ").replace(/何/g, "なに");
            return katakanaToHiragana(t);
        }

        function katakanaToHiragana(src) {
            return src.replace(/[\u30a1-\u30f6]/g, function (match) {
                var chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        }

        // Allow fuzzy matching for voicing (Rendaku): k<->g, s<->z, t<->d, h<->b/p
        function expandVoicing(char) {
            const map = {
                'か': '[かが]', 'き': '[きぎ]', 'く': '[くぐ]', 'け': '[けげ]', 'こ': '[こご]',
                'が': '[かが]', 'ぎ': '[きぎ]', 'ぐ': '[くぐ]', 'げ': '[けげ]', 'ご': '[こご]',
                'さ': '[さざ]', 'し': '[しじ]', 'す': '[すず]', 'せ': '[せぜ]', 'そ': '[そぞ]',
                'ざ': '[さざ]', 'じ': '[しじ]', 'ず': '[すず]', 'ぜ': '[せぜ]', 'ぞ': '[そぞ]',
                'た': '[ただ]', 'ち': '[ちぢ]', 'つ': '[つづ]', 'て': '[てで]', 'と': '[とど]',
                'だ': '[ただ]', 'ぢ': '[ちぢ]', 'づ': '[つづ]', 'で': '[てで]', 'ど': '[とど]',
                'は': '[はばぱ]', 'ひ': '[ひびぴ]', 'ふ': '[ふぶぷ]', 'へ': '[へべぺ]', 'ほ': '[ほぼぽ]',
                'ば': '[はばぱ]', 'び': '[ひびぴ]', 'ぶ': '[ふぶぷ]', 'べ': '[へべぺ]', 'ぼ': '[ほぼぽ]',
                'ぱ': '[はばぱ]', 'ぴ': '[ひびぴ]', 'ぷ': '[ふぶぷ]', 'ぺ': '[へべぺ]', 'ぽ': '[ほぼぽ]'
            };
            return map[char] || char; // Return regex group or original char if no variant
        }

        function normalizeNumbers(text) {
            return text.replace(/0/g, '〇').replace(/1/g, '一').replace(/2/g, '二')
                .replace(/3/g, '三').replace(/4/g, '四').replace(/5/g, '五')
                .replace(/6/g, '六').replace(/7/g, '七').replace(/8/g, '八')
                .replace(/9/g, '九');
        }

        function getLevenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;
            const matrix = [];
            for (let i = 0; i <= b.length; i++) matrix[i] = [i];
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) == a.charAt(j - 1)) matrix[i][j] = matrix[i - 1][j - 1];
                    else matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                }
            }
            return matrix[b.length][a.length];
        }

        function getSimilarity(a, b) {
            if (a.length === 0 && b.length === 0) return 1.0;
            if (a.length === 0 || b.length === 0) return 0.0;
            const dist = getLevenshteinDistance(a, b);
            const maxLen = Math.max(a.length, b.length);
            return 1.0 - (dist / maxLen);
        }

        // --- UI HELPERS ---

        function updateDisplay() {
            if (filteredSentences.length === 0) {
                document.getElementById('target-word').innerText = "-";
                document.getElementById('target-text').innerText = "No Data";
                document.getElementById('word-meaning').innerText = "";
                document.getElementById('progress-bar').style.width = "0%";
                return;
            }
            if (currentIndex >= filteredSentences.length) currentIndex = filteredSentences.length - 1;
            if (currentIndex < 0) currentIndex = 0;

            const progress = ((currentIndex + 1) / filteredSentences.length) * 100;
            document.getElementById('progress-bar').style.width = progress + "%";

            const s = filteredSentences[currentIndex];
            document.getElementById('target-word').innerText = s.word;
            document.getElementById('target-text').innerText = s.text;
            document.getElementById('target-kana').innerText = s.kana;
            document.getElementById('word-meaning').innerText = s.word_meaning;
            document.getElementById('sentence-meaning').innerText = s.sentence_meaning;
            resetStatus();
            hasPlayedCurrentCard = false;
        }

        function resetStatus() {
            document.getElementById('status').innerHTML = '<i class="fas fa-headphones"></i> Ready to listen';
            document.getElementById('status').style.color = "#6b7280";
            document.getElementById('debug').innerText = "";
            document.getElementById('btn-mic').classList.remove('listening');
        }

        let isListening = false;
        let isManualStop = false; // Flag to track manual vs auto stop
        let isSpeaking = false;
        let hasPlayedCurrentCard = false;

        function speakAndListen() {
            if (isListening) recognition.stop();
            if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();

            if (hasPlayedCurrentCard) {
                isSpeaking = false;
                isManualStop = false;
                startListening();
                return;
            }

            isSpeaking = true;
            isManualStop = false;

            const btnMic = document.getElementById('btn-mic');
            btnMic.classList.remove('listening');
            btnMic.classList.add('speaking');

            document.getElementById('status').innerHTML = '<i class="fas fa-volume-up"></i> Speaking...';
            document.getElementById('status').style.color = "#3b82f6";
            document.getElementById('debug').innerText = "";

            if (filteredSentences.length === 0 || currentIndex >= filteredSentences.length) {
                isSpeaking = false;
                btnMic.classList.remove('speaking');
                return;
            }

            const s = filteredSentences[currentIndex];
            const utterance = new SpeechSynthesisUtterance(s.text);
            utterance.lang = 'ja-JP';
            utterance.rate = 0.9;

            utterance.onend = () => {
                isSpeaking = false;
                hasPlayedCurrentCard = true;
                btnMic.classList.remove('speaking');
                if (!isManualStop) {
                    startListening();
                }
            };

            utterance.onerror = (e) => {
                console.error("SpeechSynthesis error:", e);
                isSpeaking = false;
                hasPlayedCurrentCard = true;
                btnMic.classList.remove('speaking');
                if (!isManualStop) {
                    startListening();
                }
            };

            window.speechSynthesis.speak(utterance);
        }

        function togglePlayListen() {
            if (isSpeaking || isListening) {
                isManualStop = true;
                if (isListening) recognition.stop();
                if (isSpeaking) {
                    window.speechSynthesis.cancel();
                    isSpeaking = false;
                    document.getElementById('btn-mic').classList.remove('speaking');
                }
                isListening = false;
                document.getElementById('btn-mic').classList.remove('listening');
                resetStatus();
                return;
            }
            speakAndListen();
        }

        function startListening() {
            if (!recognition) return;

            if (isListening) {
                isManualStop = true; // User clicked stop
                recognition.stop();
                isListening = false;
                document.getElementById('btn-mic').classList.remove('listening');
                return;
            }
            isListening = true;
            document.getElementById('status').innerText = "Listening...";
            document.getElementById('status').style.color = "#e67e22";
            document.getElementById('btn-mic').classList.add('listening');
            try { recognition.start(); } catch (e) { }
        }

        function nextCard() {
            if (currentIndex < filteredSentences.length - 1) {
                currentIndex++;
                saveProgress(document.getElementById('pos-filter').value, currentIndex);
                updateDisplay();
            }
        }
        function prevCard() {
            if (currentIndex > 0) {
                currentIndex--;
                saveProgress(document.getElementById('pos-filter').value, currentIndex);
                updateDisplay();
            }
        }


        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') { event.preventDefault(); togglePlayListen(); }
            else if (event.code === 'ArrowRight') nextCard();
            else if (event.code === 'ArrowLeft') prevCard();
        });

        // --- THEME TOGGLE LOGIC ---
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('japanese_practice_theme', isDark ? 'dark' : 'light');
            updateThemeUI(isDark);
        }

        function updateThemeUI(isDark) {
            const btn = document.querySelector('.theme-toggle');
            if (isDark) {
                btn.innerHTML = '<i class="fas fa-sun"></i> <span>Light Mode</span>';
            } else {
                btn.innerHTML = '<i class="fas fa-moon"></i> <span>Dark Mode</span>';
            }
        }

        // Init Theme
        (function initTheme() {
            const savedTheme = localStorage.getItem('japanese_practice_theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.body.classList.add('dark-mode');
                updateThemeUI(true);
            } else {
                updateThemeUI(false);
            }
        })();
    </script>
</body>

</html>
